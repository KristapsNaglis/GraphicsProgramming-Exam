<html>
<head>
    <meta charset="UTF-8">
    <title>Kristaps Naglis</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%
        }
    </style>
</head>
<body>
<script src="three.min.js"></script>
<script src="OrbitControls.js"></script>

<script src='SubdivisionModifier.js'></script>
<!-- include threex.cannonjs -->
<script src='cannon.min.js'></script>
<script src='threex.cannonworld.js'></script>
<script src='threex.cannonbody.js'></script>
<script src='physi.js'></script>

<script>
    const module = {
        marsDistance: 227940,

        init() {

            var world = new CANNON.World();
            world.gravity.set(0,0,-9.82);
            world.broadphase = new CANNON.NaiveBroadphase();
            var mass = 5, radius = 1;
            var sphereShape = new CANNON.Sphere(radius); // Step 1
            var sphereBody = new CANNON.Body({mass: mass, shape: sphereShape}); // Step 2
            sphereBody.position.set(0,0,0);
            world.add(sphereBody); // Step 3

            var renderer = new THREE.WebGLRenderer({antialias: true});
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0xEEEEEE);
            renderer.shadowMap.enabled = true;
            this.renderer = renderer;
            document.body.appendChild(renderer.domElement);

            this.scene = new THREE.Scene();

            this.camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 1000);
            this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
            this.camera.position.z = 10;
            this.camera.position.y = 10;
            this.controls.update();
            this.clock = new THREE.Clock();

            this.setupEvents();
            this.createWorld();
            this.createLights();
            this.animate();

        },

        // Could be used for selecting one domino to push
        // changeSelection(obj) {
        //     if (obj != this.skysphere && this.selectedObj != obj) {
        //         if (this.selectedObj)
        //             this.selectedObj.material.color.set(new THREE.Color());
        //         this.selectedObj = obj;
        //         this.selectedObj.material.color.set(0xff0000);
        //         console.log(obj.name);
        //         return true;
        //     }
        // },

        // AtstÄt
        setupEvents() {
            // Update view on resize
            window.addEventListener('resize', () => {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
        });

            // Setup selection by mouse
        //     this.raycaster = new THREE.Raycaster();
        //     this.mouse = new THREE.Vector2();
        //     this.selectedObj = null;
        //
        //     window.addEventListener('mousemove', (event) => {
        //         this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        //     this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
        //     this.raycaster.setFromCamera(this.mouse, this.camera);
        //     var intersects = this.raycaster.intersectObjects(this.scene.children, true);
        //     for (var i = 0; i < intersects.length; i++) {
        //         if (this.changeSelection(intersects[i].object)) break;;
        //     }
        // }, false);
        },

        createWorld() {
            var plane = new THREE.Mesh(new THREE.PlaneGeometry(500, 500), new THREE.MeshStandardMaterial({
                color: 0xFFFFFF,
                metalness: 0,
                side: THREE.DoubleSide
            }));

            plane.rotation.x = Math.PI / 2;
            plane.receiveShadow	= true;
            this.scene.add(plane);

            //this.createDominoes('earth', '2k_earth_daymap.jpg' , 149.6 * 1000, 12756 / 2);
            var i;
            var j;
            for (i = 0; i < 10; i++) {
                for (j = 0; j < 10; j++) {
                    this.createDominoes("Domino-" + i + "_" + j, 0xFFFFFF, 20 * i, 20 * j);
                }
            }
        },

        createDominoes(name, color, positionX, positionZ) {
            var geometry = new THREE.BoxGeometry(10, 20, 3);
            var material = new THREE.MeshLambertMaterial( {
                color: color
            } );
            
            let domino = new THREE.Mesh(geometry, material);
            domino.receiveShadow = true;
            domino.castShadow = true;
            domino.position.set(positionX + 10, 10, positionZ + 20);
            this.scene.add(domino);
            this[name] = domino;
            //domino.distance = distance;
        },

        createLights() {
            //var light = new THREE.PointLight(0xffffff, 1.5, 2000 );

            this.spotLight = new THREE.SpotLight(0xFFFFFF);
            this.spotLight.position.set(-100, 50, -50);
            this.scene.add(this.spotLight);
        },

        animate() {
            requestAnimationFrame(() => this.animate());
            this.controls.update();
            this.renderer.render(this.scene, this.camera);
        }
    };
    module.init();


</script>
</body>
</html>